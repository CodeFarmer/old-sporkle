- [-] constant-pool
  - [X] :spacer is a kludge and I hate it
    - [X] cp-nth
      - [X] Implement
      - [X] Use everywhere
      - [X] abstract out deindex-foo
    - [X] Remove :spacer and change cp-nth
  - [X] Double!
    - longBitsToDouble
  - [ ] constant-pool-entry-value
    - [ ] Finish all the multimethods
    - [ ] Consider having a lot of constant-pool entries that are
      symbols (like Classes and methodrefs) evaluate to symbols
      instead of Strings and structs
    - [ ] Abstract out all the calculation and dereferencing repetitive
    code for :whatever-index
      - Could this by repurposing constant-value?
    - [ ] Unify field and method ref code

- [ ] tag
  - [ ] Remove remaining uses of (bytes-to-integral-type (:tag foo))

* code organisation

- [ ] What shape should the code actually be?

- [-] How should classes be expressed?
  - [-] Does the intermediate struct of byte arrays really make sense?
    - The friendly form probably doesn't need a constant pool, for example
    - [X] Is it possible to parse out the constant pool without it?
      - Specifically can CP entries contain indices that are ahead of
        themselves in the pool? The spec does not seem to prevent it.
    - [ ] Having said that, do we need it for writing?
      - Can we just write directly from the friendly form?

- [ ] What exactly should the friendly form look like?
  - Maybe this is actually the first question to ask.
